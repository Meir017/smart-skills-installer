#!/usr/bin/env dotnet

using System.Globalization;
using System.Text;
using System.Text.Json;

var repoRoot = FindRepoRoot();
var registryPath = Path.Combine(repoRoot, "src", "SmartSkills.Core", "Registry", "skills-registry.json");
var outputPath = Path.Combine(repoRoot, "skills-registry.md");

for (int i = 0; i < args.Length; i++)
{
    switch (args[i])
    {
        case "--registry" when i + 1 < args.Length: registryPath = args[++i]; break;
        case "--output" when i + 1 < args.Length: outputPath = args[++i]; break;
    }
}

Console.WriteLine($"Reading {Path.GetRelativePath(repoRoot, registryPath)}");

if (!File.Exists(registryPath))
{
    Console.Error.WriteLine($"Error: Registry file not found: {registryPath}");
    return 1;
}

var json = File.ReadAllText(registryPath);
var doc = JsonDocument.Parse(json);
var root = doc.RootElement;

var defaultRepoUrl = root.GetProperty("repoUrl").GetString()!;
var skills = root.GetProperty("skills");

var grouped = new Dictionary<string, List<SkillEntry>>
{
    ["dotnet"] = [],
    ["javascript"] = [],
    ["python"] = [],
    ["java"] = [],
};

var totalParsed = 0;
var fileExistsSkills = new List<FileExistsEntry>();

foreach (var skill in skills.EnumerateArray())
{
    var skillPath = skill.GetProperty("skillPath").GetString()!;
    var repoUrl = skill.TryGetProperty("repoUrl", out var r) ? r.GetString()! : defaultRepoUrl;
    var language = skill.GetProperty("language").GetString()!;

    // Determine strategy: "type" field
    var matchType = skill.TryGetProperty("type", out var ms) ? ms.GetString()! : "package";

    if (matchType == "file-exists")
    {
        var criteria = skill.GetProperty("matchCriteria").EnumerateArray().Select(p => p.GetString()!).ToList();
        fileExistsSkills.Add(new FileExistsEntry(criteria, skillPath, repoUrl, language));
        totalParsed++;
        continue;
    }

    var patterns = skill.TryGetProperty("matchCriteria", out var mc)
        ? mc.EnumerateArray().Select(p => p.GetString()!).ToList()
        : [];

    var entry = new SkillEntry(patterns, skillPath, repoUrl, language);
    totalParsed++;

    if (grouped.TryGetValue(language, out var list))
    {
        list.Add(entry);
    }
    else
    {
        grouped[language] = [entry];
    }
}

Console.WriteLine($"Parsed {totalParsed} skills from registry");

var sb = new StringBuilder();
sb.AppendLine("# Skill Registry");
sb.AppendLine();
sb.AppendLine("<!-- This file is auto-generated by tools/generate-skills-registry.cs — do not edit manually. -->");
sb.AppendLine();
sb.AppendLine("SmartSkills ships with a **built-in registry** of curated skills that is embedded in the core library.");
sb.AppendLine("When your project references a matching package, the corresponding skill is automatically discovered — no configuration needed.");
sb.AppendLine();
sb.Append(CultureInfo.InvariantCulture, $"Total skills: **{grouped.Values.Sum(g => g.Count) + fileExistsSkills.Count}** across **{grouped.Count(g => g.Value.Count > 0)}** ecosystems.").AppendLine();
sb.AppendLine();

var languageLabels = new Dictionary<string, string>
{
    ["dotnet"] = ".NET (NuGet)",
    ["javascript"] = "JavaScript / TypeScript (npm)",
    ["python"] = "Python (PyPI)",
    ["java"] = "Java (Maven)",
};

foreach (var (language, entries) in grouped)
{
    if (entries.Count == 0) continue;

    var label = languageLabels.GetValueOrDefault(language, language);
    sb.Append(CultureInfo.InvariantCulture, $"## {label}").AppendLine();
    sb.AppendLine();
    sb.AppendLine("| Package(s) | Skill | Source |");
    sb.AppendLine("|---|---|---|");

    foreach (var entry in entries)
    {
        var packages = string.Join(", ", entry.Patterns.Select(p => $"`{p}`"));
        var skillName = entry.SkillPath.Split('/').Last();
        var skillLink = $"[{skillName}]({entry.RepoUrl}/tree/main/{entry.SkillPath})";
        var sourceLabel = ExtractSourceLabel(entry.RepoUrl);
        sb.Append(CultureInfo.InvariantCulture, $"| {packages} | {skillLink} | {sourceLabel} |").AppendLine();
    }

    sb.AppendLine();
}

if (fileExistsSkills.Count > 0)
{
    sb.AppendLine("## Project-Level Skills (file-exists)");
    sb.AppendLine();
    sb.AppendLine("These skills are automatically installed when specific files are detected in the project root.");
    sb.AppendLine();
    sb.AppendLine("| File Pattern(s) | Skill | Ecosystem | Source |");
    sb.AppendLine("|---|---|---|---|");

    foreach (var entry in fileExistsSkills)
    {
        var patterns = string.Join(", ", entry.Patterns.Select(p => $"`{p}`"));
        var skillName = entry.SkillPath.Split('/').Last();
        var skillLink = $"[{skillName}]({entry.RepoUrl}/tree/main/{entry.SkillPath})";
        var sourceLabel = ExtractSourceLabel(entry.RepoUrl);
        sb.Append(CultureInfo.InvariantCulture, $"| {patterns} | {skillLink} | {entry.Language} | {sourceLabel} |").AppendLine();
    }

    sb.AppendLine();
}

var totalSkills = grouped.Values.Sum(g => g.Count) + fileExistsSkills.Count;
var activeEcosystems = grouped.Count(g => g.Value.Count > 0);
File.WriteAllText(outputPath, sb.ToString());

var breakdown = string.Join(", ", grouped
    .Where(g => g.Value.Count > 0)
    .Select(g => $"{languageLabels.GetValueOrDefault(g.Key, g.Key)}: {g.Value.Count}"));
Console.WriteLine($"  {breakdown}");
Console.WriteLine($"Writing {Path.GetRelativePath(repoRoot, outputPath)} — {totalSkills} skills across {activeEcosystems} ecosystems");
return 0;

static string FindRepoRoot()
{
    var dir = new DirectoryInfo(Environment.CurrentDirectory);
    while (dir is not null)
    {
        if (dir.GetFiles("SmartSkills.slnx").Length > 0)
            return dir.FullName;
        dir = dir.Parent;
    }
    return Environment.CurrentDirectory;
}

static string ExtractSourceLabel(string repoUrl)
{
    // e.g. "https://github.com/microsoft/skills" -> "microsoft/skills"
    var uri = new Uri(repoUrl);
    return uri.AbsolutePath.Trim('/');
}

internal sealed record SkillEntry(List<string> Patterns, string SkillPath, string RepoUrl, string Language);
internal sealed record FileExistsEntry(List<string> Patterns, string SkillPath, string RepoUrl, string Language);
